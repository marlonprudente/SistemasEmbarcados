/*============================================================================
 *							                    Laboratorio 1
 *              EK-TM4C1294XL + Educational BooterPack MKII 
 *---------------------------------------------------------------------------*
 *                    Prof. André Schneider de Oliveira
 *            Universidade Tecnológica Federal do Paraná (UTFPR)
 *===========================================================================
 * Autores
 * 		Alan de Farias da Silva						- <alansilva@alunos.utfpr.edu.br>
 * 		Joao Gabriel Veronezi Crespim     - <joao_wyd@hotmail.com>
 *===========================================================================*/
 
#define _OPEN_SYS_ITOA_EXT
#include "cmsis_os.h"
#include "TM4C129.h"                    // Device header
#include <stdbool.h>
#include "grlib/grlib.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/*----------------------------------------------------------------------------
 * include libraries from drivers
 ----------------------------------------------------------------------------*/

#include "rgb.h"
#include "cfaf128x128x16.h"
#include "servo.h"
#include "temp.h"
#include "opt.h"
#include "buttons.h"
#include "buzzer.h"
#include "joy.h"
#include "mic.h"
#include "accel.h"
#include "led.h"

#define LED_A      0
#define LED_B      1
#define LED_C      2
#define LED_D      3
#define LED_CLK    7

int i;
int primeA;
bool foundPrime;
int primeList128[32];
int iterator128 = 0;
int32_t signals;
osThreadId start;
osThreadId keyReady;
osThreadId keyPrime;
osThreadId flagDecDiv;
osThreadId flagDecSquare;
osThreadId flagDecPrint;
osThreadId haltId;
bool condsMetDiv;
bool condsMetSquare;
uint8_t message1[] = {0x5a,0x99,0x01,0x00,0x66,0x67,0xfe,0xff,0x76,0x99,0x01,0x00,0x68,0x67,0xfe,0xff,0x7b,0x99,0x01,0x00,0x61,0x67,0xfe,0xff,0x27,0x99,0x01,0x00,0x26,0x67,0xfe,0xff,0x27,0x99,0x01,0x00,0x4c,0x67,0xfe,0xff,0x68,0x99,0x01,0x00,0x67,0x67,0xfe,0xff,0x7b,0x99,0x01,0x00,0x5a,0x67,0xfe,0xff,0x75,0x99,0x01,0x00,0x5a,0x67,0xfe,0xff,0x27,0x99,0x01,0x00,0x5f,0x67,0xfe,0xff,0x6c,0x99,0x01,0x00,0x5a,0x67,0xfe,0xff,0x7b,0x99,0x01,0x00,0x27,0x67,0xfe,0xff,0x27,0x99,0x01,0x00,0x4b,0x67,0xfe,0xff,0x76,0x99,0x01,0x00,0x5b,0x67,0xfe,0xff,0x27,0x99,0x01,0x00,0x4d,0x67,0xfe,0xff,0x6f,0x99,0x01,0x00,0x68,0x67,0xfe,0xff,0x74,0x99,0x01,0x00,0x5a,0x67,0xfe,0xff,0x7a,0x99,0x01,0x00,0x8a,0x65,0x02,0x00,0x8e,0xbf,0xfe,0xff}; 
uint8_t message2[] = {0x88,0x20,0xae,0x8b,0x33,0xe0,0x51,0x74,0xa8,0x20,0xae,0x8b,0x2f,0xe0,0x51,0x74,0xbc,0x20,0xae,0x8b,0xdd,0xdf,0x51,0x74,0x85,0x20,0xae,0x8b,0x2f,0xe0,0x51,0x74,0xa8,0x20,0xae,0x8b,0x1e,0xe0,0x51,0x74,0xb7,0x20,0xae,0x8b,0x25,0xe0,0x51,0x74,0x63,0x20,0xae,0x8b,0x16,0xe0,0x51,0x74,0xb2,0x20,0xae,0x8b,0x32,0xe0,0x51,0x74,0x63,0x20,0xae,0x8b,0x11,0xe0,0x51,0x74,0xa4,0x20,0xae,0x8b,0x28,0xe0,0x51,0x74,0xa8,0x20,0xae,0x8b,0xdd,0xdf,0x51,0x74,0x70,0x20,0xae,0x8b,0xdd,0xdf,0x51,0x74,0x97,0x20,0xae,0x8b,0x25,0xe0,0x51,0x74,0xa8,0x20,0xae,0x8b,0xdd,0xdf,0x51,0x74,0x93,0x20,0xae,0x8b,0x2c,0xe0,0x51,0x74,0xaf,0x20,0xae,0x8b,0x26,0xe0,0x51,0x74,0xa6,0x20,0xae,0x8b,0x64,0x30,0x85,0xd1,0xbe,0xdf,0x51,0x74}; 
uint8_t message3[] = {0x07,0x6a,0x00,0x00,0xb5,0x96,0xff,0xff,0x18,0x6a,0x00,0x00,0x6d,0x96,0xff,0xff,0xf7,0x69,0x00,0x00,0xbc,0x96,0xff,0xff,0x22,0x6a,0x00,0x00,0xbf,0x96,0xff,0xff,0x26,0x6a,0x00,0x00,0x6d,0x96,0xff,0xff,0xe0,0x69,0x00,0x00,0x6d,0x96,0xff,0xff,0xff,0x69,0x00,0x00,0xb6,0x96,0xff,0xff,0x1a,0x6a,0x00,0x00,0xb5,0x96,0xff,0xff,0x27,0x6a,0x00,0x00,0x6d,0x96,0xff,0xff,0x00,0x6a,0x00,0x00,0xc6,0x96,0xff,0xff,0xd3,0x69,0x00,0x00,0x93,0x96,0xff,0xff,0x1c,0x6a,0x00,0x00,0xbf,0x96,0xff,0xff,0x18,0x6a,0x00,0x00,0x6d,0x96,0xff,0xff,0xd3,0x69,0x00,0x00,0x6d,0x96,0xff,0xff,0xd3,0x69,0x00,0x00,0x6d,0x96,0xff,0xff,0xd3,0x69,0x00,0x00,0x6d,0x96,0xff,0xff,0xd3,0x69,0x00,0x00,0x8c,0x9e,0x00,0x00,0x10,0x00,0x00,0x00}; 
//uint8_t message4[] = {0xc5,0x97,0xd7,0x17,0xf7,0x68,0x28,0xe8,0xd6,0x97,0xd7,0x17,0xaf,0x68,0x28,0xe8,0xb6,0x97,0xd7,0x17,0xf0,0x68,0x28,0xe8,0xd8,0x97,0xd7,0x17,0xfb,0x68,0x28,0xe8,0xd6,0x97,0xd7,0x17,0x02,0x69,0x28,0xe8,0x91,0x97,0xd7,0x17,0xbc,0x68,0x28,0xe8,0x91,0x97,0xd7,0x17,0xd7,0x68,0x28,0xe8,0xe0,0x97,0xd7,0x17,0x03,0x69,0x28,0xe8,0xd6,0x97,0xd7,0x17,0xfb,0x68,0x28,0xe8,0x91,0x97,0xd7,0x17,0xd2,0x68,0x28,0xe8,0xd2,0x97,0xd7,0x17,0xfb,0x68,0x28,0xe8,0xda,0x97,0xd7,0x17,0xf5,0x68,0x28,0xe8,0xe0,0x97,0xd7,0x17,0x01,0x69,0x28,0xe8,0xdf,0x97,0xd7,0x17,0xf8,0x68,0x28,0xe8,0xd2,0x97,0xd7,0x17,0xaf,0x68,0x28,0xe8,0x91,0x97,0xd7,0x17,0xaf,0x68,0x28,0xe8,0x91,0x97,0xd7,0x17,0x29,0x63,0xc3,0x23,0x8f,0x68,0x28,0xe8}; 
//uint8_t message5[] = {0xcd,0x4f,0x46,0xad,0xe7,0xb0,0xb9,0x52,0x00,0x50,0x46,0xad,0xd8,0xb0,0xb9,0x52,0xf0,0x4f,0x46,0xad,0x95,0xb0,0xb9,0x52,0xde,0x4f,0x46,0xad,0xe5,0xb0,0xb9,0x52,0xfd,0x4f,0x46,0xad,0xde,0xb0,0xb9,0x52,0xf9,0x4f,0x46,0xad,0xdc,0xb0,0xb9,0x52,0xfe,0x4f,0x46,0xad,0xe9,0xb0,0xb9,0x52,0xf0,0x4f,0x46,0xad,0xda,0xb0,0xb9,0x52,0xf9,0x4f,0x46,0xad,0x95,0xb0,0xb9,0x52,0xb8,0x4f,0x46,0xad,0x95,0xb0,0xb9,0x52,0xcd,0x4f,0x46,0xad,0xe4,0xb0,0xb9,0x52,0xfd,0x4f,0x46,0xad,0xe3,0xb0,0xb9,0x52,0xab,0x4f,0x46,0xad,0xe9,0xb0,0xb9,0x52,0xfa,0x4f,0x46,0xad,0x95,0xb0,0xb9,0x52,0xdd,0x4f,0x46,0xad,0xea,0xb0,0xb9,0x52,0xf9,0x4f,0x46,0xad,0x95,0xb0,0xb9,0x52,0xab,0x4f,0x46,0xad,0x50,0x77,0xe9,0x03,0x75,0xb0,0xb9,0x52}; 
uint8_t message[140];
	
int key_part1;
int key;
char line1[17];
char line2[17];
char dec_line1[17];
char dec_line2[17];
char keyFound[32];
char keyFound32[32];
int check_word1;
int check_word2;
int primeList[5];
int primeCount = 0;
int primeIt = 0;
int testDiv;

tContext sContext;

/*----------------------------------------------------------------------------
 *  Transforming int to string
 *---------------------------------------------------------------------------*/
static void intToString(int64_t value, char * pBuf, uint32_t len, uint32_t base, uint8_t zeros){
	static const char* pAscii = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	bool n = false;
	int pos = 0, d = 0;
	int64_t tmpValue = value;

	// the buffer must not be null and at least have a length of 2 to handle one
	// digit and null-terminator
	if (pBuf == NULL || len < 2)
			return;

	// a valid base cannot be less than 2 or larger than 36
	// a base value of 2 means binary representation. A value of 1 would mean only zeros
	// a base larger than 36 can only be used if a larger alphabet were used.
	if (base < 2 || base > 36)
			return;

	if (zeros > len)
		return;
	
	// negative value
	if (value < 0)
	{
			tmpValue = -tmpValue;
			value    = -value;
			pBuf[pos++] = '-';
			n = true;
	}

	// calculate the required length of the buffer
	do {
			pos++;
			tmpValue /= base;
	} while(tmpValue > 0);


	if (pos > len)
			// the len parameter is invalid.
			return;

	if(zeros > pos){
		pBuf[zeros] = '\0';
		do{
			pBuf[d++ + (n ? 1 : 0)] = pAscii[0]; 
		}
		while(zeros > d + pos);
	}
	else
		pBuf[pos] = '\0';

	pos += d;
	do {
			pBuf[--pos] = pAscii[value % base];
			value /= base;
	} while(value > 0);
}
	
	
/*----------------------------------------------------------------------------
 *    Initializations
 ---------------------------------------------------------------------------*/
/*
void setFlag(int)

void flip_all(){
	start = !start;
	keyReady=!keyReady;
	keyPrime=!keyPrime;
	flagDecDiv=!flagDecDiv;
	flagDecSquare=false;
	flagDecPrint=false;
	finishDiv2=false;
	finishSquare=false;
	finishPrint=false;
	condsMetDiv = false;
	condsMetSquare = false;
}
*/
void init_periferics(){
	cfaf128x128x16Init();
	rgb_init();
	opt_init();
	GrContextInit(&sContext, &g_sCfaf128x128x16);
	GrFlush(&sContext);
	GrContextFontSet(&sContext, g_psFontFixed6x8);
}
//107783
void Generate_Key(void const *arg){
	primeA = 1;
	while(1){
		osSignalWait(0x01, osWaitForever);
		primeA += 2;
		osSignalSet(keyReady, 0x01);
		}	
		

}osThreadDef(Generate_Key,osPriorityNormal,1,0);

void TestPrime(void const *arg){
	while(1){
		osSignalWait(0x01, osWaitForever);	
		key = primeA + key_part1;
		foundPrime = true;
		if(key%2==0 && key != 2){
			foundPrime = !foundPrime;
			osSignalSet(start, 0x01);
		}
		else if(key%3==0 && key != 3){
			foundPrime = !foundPrime;
			osSignalSet(start, 0x01);
		}
		else if(key%5==0 && key != 5){
			foundPrime = !foundPrime;
			osSignalSet(start, 0x01);
		}
		else if(key%7==0 && key != 7){
			foundPrime = !foundPrime;
			osSignalSet(start, 0x01);
		}
		else{
			for (i = primeIt; i>0; i--){
				if (key % primeList[i] == 0 && key > 1 && primeList[i] > 1){
					foundPrime = !foundPrime;
					osSignalSet(start, 0x01);
					break;
				}
			}
			
			for (i = 0; i < 32; i++){
				foundPrime = false;
				if ((key - primeList128[i])%256 == 0){
					foundPrime = !foundPrime;
					break;
					
				}
			}
			if (foundPrime){
				
				primeList[primeCount%5] = key;
				primeIt = primeCount%5;
				primeCount++;
				osSignalSet(keyPrime, 0x01);
				
			}
			else
				osSignalSet(start, 0x01);
			
		}
	}
					

	
}osThreadDef(TestPrime,osPriorityNormal,1,0);

void Decode(void const *arg){
	while(1){
		osSignalWait(0x01, osWaitForever);
		for (i = 0; i<16; i++){
			if (i%2==0){
				dec_line1[i] = line1[i] - primeA;
				dec_line2[i] = line2[i] - primeA;
			}
				
			else{
				dec_line1[i] = line1[i] + (primeA+256);
				dec_line2[i] = line2[i] + (primeA+256);
			}
				
		}
		osSignalSet(flagDecDiv, 0x01);
		osSignalSet(flagDecSquare, 0x01);
		osSignalSet(flagDecPrint, 0x01);
		
	}
		
	
}osThreadDef(Decode,osPriorityNormal,1,0);

void Test_Div2(){

	while(1){
		osSignalWait(0x01, osWaitForever);
		testDiv = (key >> 1) + key;
		if (testDiv == check_word1){
			condsMetDiv = !condsMetDiv;
			osSignalSet(haltId, 0x01);
		}
		else
			osSignalSet(start, 0x01);
		
		
			
		
		
	}
}osThreadDef(Test_Div2,osPriorityNormal,1,0);

void Test_Square(void const *arg){
static int32_t testSquare = 0;
	while(1){
		osSignalWait(0x01, osWaitForever);
		if (primeIt > 0)
			testSquare = ((key*key)/(primeList[primeIt-1] + key_part1));
		else
			testSquare = ((key*key)/(primeList[4] + key_part1));
		if ((testSquare - key) == check_word2){
			condsMetSquare = !condsMetSquare;
			osSignalSet(haltId, 0x01);
		}
		else
			osSignalSet(start, 0x01);
		

		
		
	}
}osThreadDef(Test_Square,osPriorityNormal,1,0);

void EchoMessage(void const *arg){
	while(1){	
		osSignalWait(0x01, osWaitForever);
		sprintf(keyFound, "%d", primeList[primeIt]);	
		sprintf(keyFound32, "%d", primeList[primeIt]);	
		//sprintf(buff2, "%d", check_word2);	
		GrContextInit(&sContext, &g_sCfaf128x128x16);
	
		GrFlush(&sContext);
		GrContextFontSet(&sContext, g_psFontFixed6x8);
		
		GrContextForegroundSet(&sContext, ClrWhite);
		GrContextBackgroundSet(&sContext, ClrBlack);
		
		GrStringDraw(&sContext,dec_line1, -1, 0, (sContext.psFont->ui8Height+2)*0, true);
		GrStringDraw(&sContext,dec_line2, -1, 0, (sContext.psFont->ui8Height+2)*1, true);
		GrStringDraw(&sContext,keyFound, -1, 0, (sContext.psFont->ui8Height+2)*2, true);
		GrStringDraw(&sContext,keyFound32, -1, 0, (sContext.psFont->ui8Height+2)*3, true);
			
			
		
		
	}
}osThreadDef(EchoMessage,osPriorityNormal,1,0);

void Halt(void const *arg){
	while(1){
		osSignalWait(0x01, osWaitForever);
		if (condsMetDiv && condsMetSquare){
			while(1){
			}
		}
		else
			osSignalSet(start, 0x01);
		
		
			
	
			
	}
	
	
}osThreadDef(Halt,osPriorityNormal,1,0);
/*----------------------------------------------------------------------------
 *      Main
 ---------------------------------------------------------------------------*/
int main (void) {
	int i, j, k;
	bool prime;
	for (i = 0; i < 140; i++){
		message[i] = message1[i];
	}
	for (i = 0, j = 0; i < 16; i++, j+=4){
		line1[i] = message[j];
	}
	line1[16] = '\0';
			
	for (i = 0, j = 64; i < 16; i++, j+=4){
		line2[i] = message[j];
	}
	line2[16] = '\0';
	dec_line1[16] = '\0';
	dec_line2[16] = '\0';
	primeList128[0] = 1;
	primeList128[1] = 2;
	primeList128[2] = 3;
	for (i = 5, j = 3; i < 128; i+=2){
		prime = true;
		for (k = j-1 ; k > 0; k--){
			if (i%primeList128[k] == 0){
				prime = false;
				break;
			}
		
		}
		if (prime){
			primeList128[j] = i;
			j++;
		}
		
		
	}
	
	check_word1 = (message[135]<<24) + (message[134]<<16) + (message[133]<<8) + (message[132]);
	check_word2 = (message[139]<<24) + (message[138]<<16) + (message[137]<<8) + (message[136]);
	key_part1 = (message[3]<<24) + (message[2]<<16) + (message[1]<<8);
	init_periferics();
	osKernelInitialize();
	start=osThreadCreate(osThread(Generate_Key),NULL);
	keyReady=osThreadCreate(osThread(TestPrime),NULL);
	keyPrime=osThreadCreate(osThread(Decode),NULL);
	flagDecDiv=osThreadCreate(osThread(Test_Div2),NULL);
	flagDecSquare=osThreadCreate(osThread(Test_Square),NULL);
	flagDecPrint=osThreadCreate(osThread(EchoMessage),NULL);
	haltId=osThreadCreate(osThread(Halt),NULL);
	signals = osSignalSet (start, 0x01);
	osKernelStart();
	if (osKernelRunning() == 0){
		osDelay(1000);
	}
	
	//extern unsigned char stack_img;
	//Initializing all peripherals
	//Sidelong menu creation
  osThreadTerminate(osThreadGetId());
}